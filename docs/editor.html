<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Map Editor</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#1a1a2e;font-family:'Segoe UI',system-ui,sans-serif;color:#ccc}
canvas{display:block}

/* ── Sidebar ── */
#sidebar{position:fixed;left:0;top:0;bottom:0;width:220px;background:#12121f;
  display:flex;flex-direction:column;border-right:1px solid #2a2a3e;z-index:10}
#sidebar h1{padding:10px 12px;font-size:15px;font-weight:700;color:#e8c44a;
  border-bottom:1px solid #2a2a3e;letter-spacing:1px;text-align:center}

/* info bar */
#info{padding:6px 10px;font-size:10px;color:#666;border-bottom:1px solid #1a1a2e;line-height:1.7}
#info kbd{background:#2a2a3e;padding:1px 5px;border-radius:3px;color:#bbb;font-family:monospace;font-size:9px}
#cell-display{padding:4px 10px;font-size:10px;color:#888;border-bottom:1px solid #1a1a2e}

/* palette area */
#palette-wrap{flex:1;overflow-y:auto;padding:6px 8px}
.cat{color:#555;font-size:9px;text-transform:uppercase;padding:8px 2px 3px;letter-spacing:1.2px;font-weight:700}
.obj-btn{padding:4px 8px;margin:1px 0;cursor:pointer;border-radius:4px;font-size:10px;
  color:#999;transition:all .12s;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.obj-btn:hover{background:#252540;color:#ddd}
.obj-btn.active{background:#2a2a50;color:#e8c44a;font-weight:600}

/* object controls */
#obj-controls{padding:8px 10px;border-top:1px solid #2a2a3e;font-size:10px}
#obj-controls .row{display:flex;gap:4px;align-items:center;margin-bottom:4px}
#obj-controls label{color:#666;min-width:40px}
#obj-controls input[type=range]{flex:1;height:4px;accent-color:#e8c44a}
#obj-controls .val{font-size:10px;color:#e8c44a;min-width:32px;text-align:right;font-family:monospace}

/* buttons */
#btns{padding:8px 10px;border-top:1px solid #2a2a3e;display:flex;gap:4px;flex-wrap:wrap}
#btns button{flex:1;min-width:60px;padding:6px;font-size:10px;cursor:pointer;
  background:#1e1e32;color:#ccc;border:1px solid #333;border-radius:4px;font-family:inherit;transition:all .12s}
#btns button:hover{background:#2a2a50;border-color:#555}

#count{padding:5px 10px;font-size:10px;color:#555;text-align:center;border-top:1px solid #1a1a2e;font-family:monospace}

/* ── Canvas ── */
#canvas-wrap{position:fixed;left:220px;top:0;right:0;bottom:0}

/* hidden */
.hidden{display:none!important}
</style>
</head>
<body>

<div id="sidebar">
  <h1>MAP EDITOR</h1>
  <div id="info">
    <kbd>Click</kbd> place &nbsp; <kbd>RClick</kbd> remove<br>
    <kbd>R</kbd> rotate 45° &nbsp; <kbd>G</kbd> toggle grid<br>
    <kbd>Shift+Scroll</kbd> resize &nbsp; <kbd>Del</kbd> delete selected<br>
    <kbd>Ctrl+S</kbd> export &nbsp; <kbd>Ctrl+Z</kbd> undo &nbsp; <kbd>Esc</kbd> deselect
  </div>
  <div id="cell-display">—</div>
  <div id="palette-wrap"></div>

  <div id="obj-controls">
    <div class="row"><label>Scale</label>
      <input type="range" id="obj-scale" min="0.2" max="5" step="0.1" value="1.0">
      <span class="val" id="obj-scale-val">1.00</span>
    </div>
    <div class="row"><label>Rot</label>
      <input type="range" id="obj-rot" min="0" max="6.28" step="0.05" value="0">
      <span class="val" id="obj-rot-val">0°</span>
    </div>
  </div>

  <div id="btns">
    <button id="btn-export">Export JSON</button>
    <button id="btn-import">Import JSON</button>
    <button id="btn-clear">Clear All</button>
  </div>
  <div id="count">0 objects</div>
</div>

<div id="canvas-wrap"></div>
<input type="file" id="file-input" accept=".json" style="display:none">

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

/* ═══════════════════════════════════════════
   Constants
   ═══════════════════════════════════════════ */
const TILE_S = 2;
const TILE_DIR = "models/terrain/";
const MODEL_DIR = "models/";

/* ═══════════════════════════════════════════
   Object catalogue
   ═══════════════════════════════════════════ */
const OBJ_CATEGORIES = [
  { name: "Trees", items: [
    { id: "Tree_1_A", file: "Tree_1_A_Color1.gltf", scale: 2.0 },
    { id: "Tree_1_B", file: "Tree_1_B_Color1.gltf", scale: 2.0 },
    { id: "Tree_1_C", file: "Tree_1_C_Color1.gltf", scale: 2.0 },
    { id: "Tree_2_A", file: "Tree_2_A_Color1.gltf", scale: 2.0 },
    { id: "Tree_2_B", file: "Tree_2_B_Color1.gltf", scale: 2.0 },
    { id: "Tree_2_C", file: "Tree_2_C_Color1.gltf", scale: 2.0 },
    { id: "Tree_3_A", file: "Tree_3_A_Color1.gltf", scale: 2.0 },
    { id: "Tree_3_B", file: "Tree_3_B_Color1.gltf", scale: 2.0 },
    { id: "Tree_4_A", file: "Tree_4_A_Color1.gltf", scale: 2.0 },
    { id: "Tree_4_B", file: "Tree_4_B_Color1.gltf", scale: 2.0 },
    { id: "Tree_Bare_1_A", file: "Tree_Bare_1_A_Color1.gltf", scale: 2.0 },
    { id: "Tree_Bare_2_A", file: "Tree_Bare_2_A_Color1.gltf", scale: 2.0 },
  ]},
  { name: "Rocks", items: [
    { id: "Rock_1_A", file: "Rock_1_A_Color1.gltf", scale: 1.0 },
    { id: "Rock_1_J", file: "Rock_1_J_Color1.gltf", scale: 1.0 },
    { id: "Rock_1_K", file: "Rock_1_K_Color1.gltf", scale: 1.0 },
    { id: "Rock_2_A", file: "Rock_2_A_Color1.gltf", scale: 1.0 },
    { id: "Rock_3_A", file: "Rock_3_A_Color1.gltf", scale: 1.0 },
    { id: "Rock_3_C", file: "Rock_3_C_Color1.gltf", scale: 1.0 },
    { id: "Rock_3_E", file: "Rock_3_E_Color1.gltf", scale: 1.0 },
    { id: "Rock_3_G", file: "Rock_3_G_Color1.gltf", scale: 1.0 },
  ]},
  { name: "Bushes", items: [
    { id: "Bush_1_A", file: "Bush_1_A_Color1.gltf", scale: 1.0 },
    { id: "Bush_2_A", file: "Bush_2_A_Color1.gltf", scale: 1.0 },
    { id: "Bush_3_A", file: "Bush_3_A_Color1.gltf", scale: 1.0 },
    { id: "Bush_4_A", file: "Bush_4_A_Color1.gltf", scale: 1.0 },
  ]},
  { name: "Grass/Flowers", items: [
    { id: "Grass_1_A", file: "Grass_1_A_Color1.gltf", scale: 1.0 },
    { id: "Grass_2_A", file: "Grass_2_A_Color1.gltf", scale: 1.0 },
  ]},
  { name: "Terrain Props", dir: TILE_DIR, items: [
    { id: "Prop_Grass_Clump_1", file: "Prop_Grass_Clump_1.glb", scale: 1.0 },
    { id: "Prop_Grass_Clump_2", file: "Prop_Grass_Clump_2.glb", scale: 1.0 },
    { id: "Prop_Grass_Clump_3", file: "Prop_Grass_Clump_3.glb", scale: 1.0 },
    { id: "Prop_Grass_Clump_4", file: "Prop_Grass_Clump_4.glb", scale: 1.0 },
    { id: "Prop_Flower_Daisy", file: "Prop_Flower_Daisy.glb", scale: 1.0 },
    { id: "Prop_Flower_Rose", file: "Prop_Flower_Rose.glb", scale: 1.0 },
    { id: "Prop_Flower_Sunflower", file: "Prop_Flower_Sunflower.glb", scale: 1.0 },
    { id: "Prop_Flower_Tulip", file: "Prop_Flower_Tulip.glb", scale: 1.0 },
    { id: "Prop_Flower_Lily_Blue", file: "Prop_Flower_Lily_Blue.glb", scale: 1.0 },
    { id: "Prop_Flower_Lily_Pink", file: "Prop_Flower_Lily_Pink.glb", scale: 1.0 },
    { id: "Prop_Cattail_1", file: "Prop_Cattail_1.glb", scale: 1.0 },
    { id: "Prop_Cattail_2", file: "Prop_Cattail_2.glb", scale: 1.0 },
    { id: "Prop_Mushroom_1", file: "Prop_Mushroom_1.glb", scale: 1.0 },
    { id: "Prop_Mushroom_2", file: "Prop_Mushroom_2.glb", scale: 1.0 },
    { id: "Prop_Stump", file: "Prop_Stump.glb", scale: 1.0 },
    { id: "Prop_Hollow_Trunk", file: "Prop_Hollow_Trunk.glb", scale: 1.0 },
    { id: "Prop_Branch_1", file: "Prop_Branch_1.glb", scale: 1.0 },
    { id: "Prop_Branch_2", file: "Prop_Branch_2.glb", scale: 1.0 },
    { id: "Prop_Branch_3", file: "Prop_Branch_3.glb", scale: 1.0 },
    { id: "Prop_Rock_1", file: "Prop_Rock_1.glb", scale: 1.0 },
    { id: "Prop_Rock_2", file: "Prop_Rock_2.glb", scale: 1.0 },
    { id: "Prop_Rock_3", file: "Prop_Rock_3.glb", scale: 1.0 },
    { id: "Prop_Rock_4", file: "Prop_Rock_4.glb", scale: 1.0 },
    { id: "Prop_Bush_1", file: "Prop_Bush_1.glb", scale: 1.0 },
    { id: "Prop_Bush_2", file: "Prop_Bush_2.glb", scale: 1.0 },
    { id: "Prop_Bush_3", file: "Prop_Bush_3.glb", scale: 1.0 },
    { id: "Prop_Cliff_Rock_1", file: "Prop_Cliff_Rock_1.glb", scale: 1.0 },
    { id: "Prop_Cliff_Rock_2", file: "Prop_Cliff_Rock_2.glb", scale: 1.0 },
    { id: "Prop_Shell_1", file: "Prop_Shell_1.glb", scale: 1.0 },
    { id: "Prop_Shell_2", file: "Prop_Shell_2.glb", scale: 1.0 },
    { id: "Prop_Starfish_1", file: "Prop_Starfish_1.glb", scale: 1.0 },
    { id: "Prop_Starfish_2", file: "Prop_Starfish_2.glb", scale: 1.0 },
    { id: "Prop_Treasure_Chest", file: "Prop_Treasure_Chest.glb", scale: 1.0 },
  ]},
  { name: "Terrain Trees", dir: TILE_DIR, items: [
    { id: "Prop_Tree_Cedar_1", file: "Prop_Tree_Cedar_1.glb", scale: 1.0 },
    { id: "Prop_Tree_Cedar_2", file: "Prop_Tree_Cedar_2.glb", scale: 1.0 },
    { id: "Prop_Tree_Oak_1", file: "Prop_Tree_Oak_1.glb", scale: 1.0 },
    { id: "Prop_Tree_Oak_2", file: "Prop_Tree_Oak_2.glb", scale: 1.0 },
    { id: "Prop_Tree_Oak_3", file: "Prop_Tree_Oak_3.glb", scale: 1.0 },
    { id: "Prop_Tree_Palm_1", file: "Prop_Tree_Palm_1.glb", scale: 1.0 },
    { id: "Prop_Tree_Palm_2", file: "Prop_Tree_Palm_2.glb", scale: 1.0 },
    { id: "Prop_Tree_Palm_3", file: "Prop_Tree_Palm_3.glb", scale: 1.0 },
    { id: "Prop_Tree_Pine_1", file: "Prop_Tree_Pine_1.glb", scale: 1.0 },
    { id: "Prop_Tree_Pine_2", file: "Prop_Tree_Pine_2.glb", scale: 1.0 },
    { id: "Prop_Tree_Pine_3", file: "Prop_Tree_Pine_3.glb", scale: 1.0 },
  ]},
  { name: "Fences", dir: TILE_DIR, items: [
    { id: "Prop_Fence_Boards_1", file: "Prop_Fence_Boards_1.glb", scale: 1.0 },
    { id: "Prop_Fence_Boards_2", file: "Prop_Fence_Boards_2.glb", scale: 1.0 },
    { id: "Prop_Fence_Boards_3", file: "Prop_Fence_Boards_3.glb", scale: 1.0 },
    { id: "Prop_Fence_Boards_4", file: "Prop_Fence_Boards_4.glb", scale: 1.0 },
    { id: "Prop_Fence_Post_1", file: "Prop_Fence_Post_1.glb", scale: 1.0 },
    { id: "Prop_Fence_Post_2", file: "Prop_Fence_Post_2.glb", scale: 1.0 },
    { id: "Prop_Fence_Post_3", file: "Prop_Fence_Post_3.glb", scale: 1.0 },
    { id: "Prop_Fence_Post_4", file: "Prop_Fence_Post_4.glb", scale: 1.0 },
    { id: "Prop_Fence_Curve_1x1", file: "Prop_Fence_Curve_1x1.glb", scale: 1.0 },
    { id: "Prop_Fence_Curve_2x2", file: "Prop_Fence_Curve_2x2.glb", scale: 1.0 },
    { id: "Prop_Fence_Curve_3x3", file: "Prop_Fence_Curve_3x3.glb", scale: 1.0 },
    { id: "Prop_Fence_Gate_1", file: "Prop_Fence_Gate_1.glb", scale: 1.0 },
    { id: "Prop_Fence_Gate_2", file: "Prop_Fence_Gate_2.glb", scale: 1.0 },
    { id: "Prop_Fence_Hill_Gentle", file: "Prop_Fence_Hill_Gentle.glb", scale: 1.0 },
    { id: "Prop_Fence_Hill_Sharp", file: "Prop_Fence_Hill_Sharp.glb", scale: 1.0 },
  ]},
  { name: "Bridge", dir: TILE_DIR, items: [
    { id: "Prop_Bridge_Log_End", file: "Prop_Bridge_Log_End.glb", scale: 1.0 },
    { id: "Prop_Bridge_Log_End_Edge", file: "Prop_Bridge_Log_End_Edge.glb", scale: 1.0 },
    { id: "Prop_Bridge_Log_Middle", file: "Prop_Bridge_Log_Middle.glb", scale: 1.0 },
    { id: "Prop_Bridge_Log_Middle_Edge", file: "Prop_Bridge_Log_Middle_Edge.glb", scale: 1.0 },
    { id: "Prop_Bridge_Log_Post_Support", file: "Prop_Bridge_Log_Post_Support.glb", scale: 1.0 },
    { id: "Prop_Bridge_Log_Post_Top", file: "Prop_Bridge_Log_Post_Top.glb", scale: 1.0 },
    { id: "Prop_Bridge_Rope_End", file: "Prop_Bridge_Rope_End.glb", scale: 1.0 },
    { id: "Prop_Bridge_Rope_Middle", file: "Prop_Bridge_Rope_Middle.glb", scale: 1.0 },
    { id: "Prop_Bridge_Rope_Rope_Support", file: "Prop_Bridge_Rope_Rope_Support.glb", scale: 1.0 },
  ]},
  { name: "Dock", dir: TILE_DIR, items: [
    { id: "Prop_Docks_Straight", file: "Prop_Docks_Straight.glb", scale: 1.0 },
    { id: "Prop_Docks_Straight_Supports", file: "Prop_Docks_Straight_Supports.glb", scale: 1.0 },
    { id: "Prop_Docks_Steps", file: "Prop_Docks_Steps.glb", scale: 1.0 },
    { id: "Prop_Docks_Corner", file: "Prop_Docks_Corner.glb", scale: 1.0 },
    { id: "Prop_Docks_Corner_Supports", file: "Prop_Docks_Corner_Supports.glb", scale: 1.0 },
  ]},
];

/* ═══════════════════════════════════════════
   Three.js Setup
   ═══════════════════════════════════════════ */
const wrap = document.getElementById("canvas-wrap");
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio || 1, 2));
renderer.setSize(wrap.clientWidth, wrap.clientHeight);
renderer.setClearColor(0x1a1a2e);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.NoToneMapping;
wrap.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, wrap.clientWidth / wrap.clientHeight, 0.5, 500);
camera.position.set(20, 30, 40);

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0, 0);
controls.enableDamping = true;
controls.dampingFactor = 0.1;
controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.PAN, RIGHT: null };
controls.update();

/* Lighting */
scene.add(new THREE.HemisphereLight("#f0fbff", "#6aa057", 0.92));
scene.add(new THREE.AmbientLight("#ffffff", 0.18));
const sun = new THREE.DirectionalLight("#fff2d0", 1.46);
sun.position.set(42, 54, 18); scene.add(sun);
const fill = new THREE.DirectionalLight("#d8efff", 0.32);
fill.position.set(-34, 26, -24); scene.add(fill);

/* ═══════════════════════════════════════════
   Grid + ground plane visual
   ═══════════════════════════════════════════ */
const GRID_MIN = -25, GRID_MAX = 25;
const gridGroup = new THREE.Group(); gridGroup.name = "grid";

function buildGrid() {
  const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.12 });
  const pts = [];
  for (let i = GRID_MIN; i <= GRID_MAX + 1; i++) {
    const x = i * TILE_S;
    pts.push(new THREE.Vector3(x, 0.01, GRID_MIN * TILE_S), new THREE.Vector3(x, 0.01, (GRID_MAX + 1) * TILE_S));
  }
  for (let j = GRID_MIN; j <= GRID_MAX + 1; j++) {
    const z = j * TILE_S;
    pts.push(new THREE.Vector3(GRID_MIN * TILE_S, 0.01, z), new THREE.Vector3((GRID_MAX + 1) * TILE_S, 0.01, z));
  }
  gridGroup.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(pts), mat));
  const axMat = new THREE.LineBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.35 });
  const axPts = [
    new THREE.Vector3(GRID_MIN * TILE_S, 0.02, 0), new THREE.Vector3((GRID_MAX + 1) * TILE_S, 0.02, 0),
    new THREE.Vector3(0, 0.02, GRID_MIN * TILE_S), new THREE.Vector3(0, 0.02, (GRID_MAX + 1) * TILE_S),
  ];
  gridGroup.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(axPts), axMat));
  scene.add(gridGroup);
}
buildGrid();

/* Flat green ground plane so you can see where you're placing */
const groundGeo = new THREE.PlaneGeometry((GRID_MAX - GRID_MIN + 1) * TILE_S, (GRID_MAX - GRID_MIN + 1) * TILE_S);
groundGeo.rotateX(-Math.PI / 2);
const groundMesh = new THREE.Mesh(groundGeo, new THREE.MeshToonMaterial({ color: "#4dad38" }));
groundMesh.position.set((GRID_MIN + GRID_MAX + 1) * TILE_S / 2, -0.01, (GRID_MIN + GRID_MAX + 1) * TILE_S / 2);
scene.add(groundMesh);

/* Hover highlight */
const hoverGeo = new THREE.PlaneGeometry(TILE_S, TILE_S);
const hoverMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.18, side: THREE.DoubleSide, depthTest: false });
const hoverMesh = new THREE.Mesh(hoverGeo, hoverMat);
hoverMesh.rotation.x = -Math.PI / 2; hoverMesh.position.y = 0.03; hoverMesh.visible = false; hoverMesh.renderOrder = 999;
scene.add(hoverMesh);

/* ═══════════════════════════════════════════
   Model Loading
   ═══════════════════════════════════════════ */
THREE.Cache.enabled = true;
const loader = new GLTFLoader();
const objLib = {};
const allObjItems = OBJ_CATEGORIES.flatMap(c => c.items.map(it => ({ ...it, dir: c.dir || MODEL_DIR })));

async function loadAllModels() {
  const status = document.getElementById("count");
  const total = allObjItems.length;
  let loaded = 0;
  status.textContent = `Loading 0/${total}...`;

  const loadOne = (url) => new Promise(res => {
    loader.load(url, gltf => res(gltf.scene), undefined, () => res(null));
  });

  await Promise.all(allObjItems.map(async item => {
    const s = await loadOne(item.dir + item.file);
    if (s) objLib[item.id] = s;
    status.textContent = `Loading ${++loaded}/${total}...`;
  }));

  const msg = `Loaded ${Object.keys(objLib).length}/${total} models`;
  status.textContent = msg;
  status.style.color = "#4a4";
  console.log(msg);
}

/* ═══════════════════════════════════════════
   State
   ═══════════════════════════════════════════ */
let selectedObj = null;
let objScale = 1.0;
let objRot = 0;
let hoverCell = null;

let nextObjId = 1;
const objects = [];
let selectedInstance = null;
let highlightRing = null;

/* Undo */
const undoStack = [];
const MAX_UNDO = 100;
function pushUndo(action) { undoStack.push(action); if (undoStack.length > MAX_UNDO) undoStack.shift(); }

function undo() {
  const action = undoStack.pop();
  if (!action) return;
  if (action.type === "place") {
    const idx = objects.findIndex(o => o.id === action.objId);
    if (idx >= 0) { scene.remove(objects[idx].mesh); objects.splice(idx, 1); }
  } else if (action.type === "remove") {
    const { data } = action;
    const tmpl = objLib[data.type];
    if (tmpl) {
      const mesh = tmpl.clone();
      mesh.scale.setScalar(data.scale);
      mesh.position.set(data.x, data.y, data.z);
      mesh.rotation.y = data.rot;
      scene.add(mesh);
      objects.push({ ...data, mesh });
    }
  }
  updateCount();
}

/* ═══════════════════════════════════════════
   Preview ghost
   ═══════════════════════════════════════════ */
let previewObj = null;
function updatePreview() {
  if (previewObj) { scene.remove(previewObj); previewObj = null; }
  if (!hoverCell || !selectedObj) return;
  const tmpl = objLib[selectedObj];
  if (!tmpl) return;
  const obj = tmpl.clone();
  obj.scale.setScalar(objScale);
  obj.position.set(hoverCell.wx, 0.02, hoverCell.wz);
  obj.rotation.y = objRot;
  obj.traverse(c => { if (c.isMesh) { c.material = c.material.clone(); c.material.transparent = true; c.material.opacity = 0.35; c.material.depthWrite = false; } });
  obj.renderOrder = 998; previewObj = obj; scene.add(obj);
}

/* ═══════════════════════════════════════════
   Place / Remove Objects
   ═══════════════════════════════════════════ */
function placeObject(wx, wz) {
  if (!selectedObj) return;
  const tmpl = objLib[selectedObj];
  if (!tmpl) return;
  const mesh = tmpl.clone();
  mesh.scale.setScalar(objScale);
  mesh.position.set(wx, 0, wz);
  mesh.rotation.y = objRot;
  scene.add(mesh);
  const id = nextObjId++;
  const entry = { id, type: selectedObj, x: wx, z: wz, y: 0, scale: objScale, rot: objRot, mesh };
  objects.push(entry);
  pushUndo({ type: "place", objId: id });
  selectInstance(entry);
  updateCount();
}

function removeObjectAt(wx, wz) {
  let best = null, bestDist = TILE_S * 1.5;
  for (const obj of objects) {
    const d = Math.hypot(obj.x - wx, obj.z - wz);
    if (d < bestDist) { bestDist = d; best = obj; }
  }
  if (!best) return;
  pushUndo({ type: "remove", data: { id: best.id, type: best.type, x: best.x, z: best.z, y: best.y, scale: best.scale, rot: best.rot } });
  scene.remove(best.mesh);
  objects.splice(objects.indexOf(best), 1);
  if (selectedInstance === best) deselectInstance();
  updateCount();
}

function findObjectAt(wx, wz) {
  let best = null, bestDist = TILE_S * 1.2;
  for (const obj of objects) {
    const d = Math.hypot(obj.x - wx, obj.z - wz);
    if (d < bestDist) { bestDist = d; best = obj; }
  }
  return best;
}

/* Selection ring */
function createHighlightRing() {
  const geo = new THREE.RingGeometry(0.8, 1.0, 24);
  const mat = new THREE.MeshBasicMaterial({ color: 0xe8c44a, transparent: true, opacity: 0.6, side: THREE.DoubleSide, depthTest: false });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = -Math.PI / 2; mesh.renderOrder = 1000; mesh.visible = false;
  scene.add(mesh); return mesh;
}

function selectInstance(obj) {
  selectedInstance = obj;
  if (!highlightRing) highlightRing = createHighlightRing();
  highlightRing.visible = true;
  highlightRing.position.set(obj.x, obj.y + 0.05, obj.z);
  highlightRing.scale.setScalar(obj.scale);
  document.getElementById("obj-scale").value = obj.scale;
  document.getElementById("obj-scale-val").textContent = obj.scale.toFixed(2);
  document.getElementById("obj-rot").value = obj.rot;
  document.getElementById("obj-rot-val").textContent = Math.round(obj.rot * 180 / Math.PI) + "°";
  objScale = obj.scale; objRot = obj.rot;
}

function deselectInstance() {
  selectedInstance = null;
  if (highlightRing) highlightRing.visible = false;
}

function updateSelectedInstance() {
  if (!selectedInstance) return;
  selectedInstance.scale = objScale;
  selectedInstance.rot = objRot;
  selectedInstance.mesh.scale.setScalar(objScale);
  selectedInstance.mesh.rotation.y = objRot;
  if (highlightRing) {
    highlightRing.position.set(selectedInstance.x, selectedInstance.y + 0.05, selectedInstance.z);
    highlightRing.scale.setScalar(objScale);
  }
}

/* ═══════════════════════════════════════════
   Raycasting
   ═══════════════════════════════════════════ */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

function screenToWorld(e) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const target = new THREE.Vector3();
  if (!raycaster.ray.intersectPlane(groundPlane, target)) return null;
  return { gx: Math.floor(target.x / TILE_S), gz: Math.floor(target.z / TILE_S), wx: target.x, wz: target.z };
}

/* ═══════════════════════════════════════════
   Input
   ═══════════════════════════════════════════ */
let mouseDownPos = null;

renderer.domElement.addEventListener("mousedown", e => {
  mouseDownPos = { x: e.clientX, y: e.clientY };
});

renderer.domElement.addEventListener("mouseup", e => {
  if (!mouseDownPos) return;
  if (Math.abs(e.clientX - mouseDownPos.x) > 4 || Math.abs(e.clientY - mouseDownPos.y) > 4) return;
  const hit = screenToWorld(e);
  if (!hit) return;

  if (e.button === 0) {
    const existing = findObjectAt(hit.wx, hit.wz);
    if (existing && !selectedObj) { selectInstance(existing); }
    else if (selectedObj) { placeObject(hit.wx, hit.wz); }
    else if (existing) { selectInstance(existing); }
  }
  if (e.button === 2) removeObjectAt(hit.wx, hit.wz);
});

renderer.domElement.addEventListener("contextmenu", e => e.preventDefault());

renderer.domElement.addEventListener("mousemove", e => {
  const hit = screenToWorld(e);
  hoverCell = hit;
  if (hit) {
    hoverMesh.position.x = hit.gx * TILE_S + TILE_S / 2;
    hoverMesh.position.z = hit.gz * TILE_S + TILE_S / 2;
    hoverMesh.visible = true;
    let label = `${hit.wx.toFixed(1)}, ${hit.wz.toFixed(1)}`;
    const near = findObjectAt(hit.wx, hit.wz);
    if (near) label += ` [${near.type}]`;
    document.getElementById("cell-display").textContent = label;
  } else {
    hoverMesh.visible = false;
  }
  updatePreview();
});

window.addEventListener("keydown", e => {
  if (e.key === "r" || e.key === "R") {
    objRot = (objRot + Math.PI / 4) % (Math.PI * 2);
    document.getElementById("obj-rot").value = objRot;
    document.getElementById("obj-rot-val").textContent = Math.round(objRot * 180 / Math.PI) + "°";
    updateSelectedInstance(); updatePreview();
  }
  if (e.key === "g" || e.key === "G") gridGroup.visible = !gridGroup.visible;
  if (e.key === "s" && e.ctrlKey) { e.preventDefault(); exportJSON(); }
  if (e.key === "z" && e.ctrlKey) { e.preventDefault(); undo(); }
  if (e.key === "Escape") { deselectInstance(); selectedObj = null; updatePaletteSelection(); updatePreview(); }
  if (e.key === "Delete" && selectedInstance) {
    const obj = selectedInstance;
    pushUndo({ type: "remove", data: { id: obj.id, type: obj.type, x: obj.x, z: obj.z, y: obj.y, scale: obj.scale, rot: obj.rot } });
    scene.remove(obj.mesh); objects.splice(objects.indexOf(obj), 1); deselectInstance(); updateCount();
  }
});

renderer.domElement.addEventListener("wheel", e => {
  if (!e.shiftKey) return;
  e.preventDefault();
  const delta = e.deltaY > 0 ? -0.1 : 0.1;
  objScale = Math.max(0.2, Math.min(5, objScale + delta));
  document.getElementById("obj-scale").value = objScale;
  document.getElementById("obj-scale-val").textContent = objScale.toFixed(2);
  updateSelectedInstance(); updatePreview();
}, { passive: false });

/* ═══════════════════════════════════════════
   Palette
   ═══════════════════════════════════════════ */
function buildPalette() {
  const pal = document.getElementById("palette-wrap");
  pal.innerHTML = "";
  for (const cat of OBJ_CATEGORIES) {
    const h = document.createElement("div"); h.className = "cat"; h.textContent = cat.name; pal.appendChild(h);
    for (const item of cat.items) {
      const d = document.createElement("div");
      d.className = "obj-btn" + (item.id === selectedObj ? " active" : "");
      d.textContent = item.id.replace(/_/g, " ");
      d.dataset.obj = item.id;
      d.addEventListener("click", () => {
        if (selectedObj === item.id) { selectedObj = null; }
        else { selectedObj = item.id; objScale = item.scale; document.getElementById("obj-scale").value = objScale; document.getElementById("obj-scale-val").textContent = objScale.toFixed(2); }
        deselectInstance(); updatePaletteSelection(); updatePreview();
      });
      pal.appendChild(d);
    }
  }
}

function updatePaletteSelection() {
  document.querySelectorAll(".obj-btn").forEach(d => d.classList.toggle("active", d.dataset.obj === selectedObj));
}

function updateCount() {
  document.getElementById("count").textContent = `${objects.length} objects`;
  document.getElementById("count").style.color = "#555";
}

/* ═══════════════════════════════════════════
   Controls (scale/rot sliders)
   ═══════════════════════════════════════════ */
document.getElementById("obj-scale").addEventListener("input", e => {
  objScale = parseFloat(e.target.value);
  document.getElementById("obj-scale-val").textContent = objScale.toFixed(2);
  updateSelectedInstance(); updatePreview();
});
document.getElementById("obj-rot").addEventListener("input", e => {
  objRot = parseFloat(e.target.value);
  document.getElementById("obj-rot-val").textContent = Math.round(objRot * 180 / Math.PI) + "°";
  updateSelectedInstance(); updatePreview();
});

/* ═══════════════════════════════════════════
   Export / Import
   ═══════════════════════════════════════════ */
function exportJSON() {
  const objData = objects.map(o => ({ type: o.type, x: +o.x.toFixed(2), z: +o.z.toFixed(2), y: o.y, scale: +o.scale.toFixed(2), rot: +o.rot.toFixed(3) }));
  const payload = { version: 2, tileSize: TILE_S, objects: objData };
  const json = JSON.stringify(payload, null, 2);
  const blob = new Blob([json], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = "objectmap.json"; a.click();
  URL.revokeObjectURL(url);
  console.log(`Exported ${objects.length} objects`);
}

function importJSON(json) {
  try {
    const data = JSON.parse(json);
    const importedObjects = data.objects;
    if (!importedObjects) { alert("No objects array found in JSON"); return; }

    /* Clear */
    for (const obj of objects) scene.remove(obj.mesh);
    objects.length = 0; deselectInstance();

    for (const entry of importedObjects) {
      const tmpl = objLib[entry.type];
      if (!tmpl) { console.warn("Unknown object:", entry.type); continue; }
      const mesh = tmpl.clone();
      mesh.scale.setScalar(entry.scale || 1);
      mesh.position.set(entry.x, entry.y || 0, entry.z);
      mesh.rotation.y = entry.rot || 0;
      scene.add(mesh);
      objects.push({ id: nextObjId++, type: entry.type, x: entry.x, z: entry.z, y: entry.y || 0, scale: entry.scale || 1, rot: entry.rot || 0, mesh });
    }
    updateCount();
    console.log(`Imported ${objects.length} objects`);
  } catch (e) {
    alert("Invalid JSON: " + e.message);
  }
}

/* ═══════════════════════════════════════════
   Button wiring
   ═══════════════════════════════════════════ */
document.getElementById("btn-export").addEventListener("click", exportJSON);
document.getElementById("btn-import").addEventListener("click", () => document.getElementById("file-input").click());
document.getElementById("file-input").addEventListener("change", e => {
  const file = e.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = () => importJSON(reader.result);
  reader.readAsText(file); e.target.value = "";
});
document.getElementById("btn-clear").addEventListener("click", () => {
  if (!confirm("Clear all objects?")) return;
  for (const obj of objects) scene.remove(obj.mesh);
  objects.length = 0; deselectInstance(); updateCount();
});

/* ═══════════════════════════════════════════
   Resize + Animate
   ═══════════════════════════════════════════ */
window.addEventListener("resize", () => {
  const w = wrap.clientWidth, h = wrap.clientHeight;
  camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h);
});

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

/* ═══════════════════════════════════════════
   Load existing objectmap.json on startup
   ═══════════════════════════════════════════ */
async function loadExistingMap() {
  /* Try objectmap.json first, fallback to tilemap.json objects */
  for (const file of ["objectmap.json", "tilemap.json"]) {
    try {
      const resp = await fetch(`${file}?v=${Date.now()}`, { cache: "no-store" });
      if (!resp.ok) continue;
      const data = await resp.json();
      if (data.objects && data.objects.length) {
        importJSON(JSON.stringify(data));
        console.log(`Auto-loaded objects from ${file}`);
        return;
      }
    } catch (e) { /* try next */ }
  }
  console.log("No existing object map found");
}

/* ═══════════════════════════════════════════
   Show existing hard-coded game objects as ghosts
   ═══════════════════════════════════════════ */
async function loadExistingGameObjects() {
  /* These match the spots defined in world.js / terrainLayout.js */
  const TREE_SPOTS = [
    [20,18,2.2,1.8],[28,28,2.4,3.6],[18,28,2.1,0.9],[32,20,1.9,2.4],[24,32,2.3,4.2],
    [-22,18,2.0,1.0],[-30,24,1.9,5.2],[-20,26,2.2,4.5],[-16,-18,1.7,2.1],[14,-18,1.6,0.7],[-8,-42,2.4,3.3],
    [10,30,1.8,0.5],[-10,22,2.0,3.1],[36,28,1.7,4.4],[-34,16,1.9,1.6],[-26,8,1.8,5.7],
    [6,24,1.6,2.3],[-6,16,1.7,0.2],[16,10,1.5,4.0],[-12,32,2.1,2.9],[26,14,1.8,5.1],
    [-28,-8,1.6,3.7],[22,-8,1.5,1.3],[-4,28,1.9,4.6],[30,8,1.7,0.8],[-18,4,1.6,2.5],
  ];
  const ROCK_SPOTS = [
    [-28,26,1.6,1.4],[-14,8,1.45,2.1],[-20,-6,1.4,0.9],
    [22,34,1.04,3.2],[-26,30,1.0,4.1],[34,22,0.98,5.0],[-32,18,0.95,2.6],
    [-10,14,0.95,1.7],[-16,10,1.0,5.3],[8,20,0.9,0.5],[14,12,1.05,3.9],
    [-22,-2,0.92,2.4],[-18,-10,0.98,4.6],[6,8,0.88,1.2],[-8,4,1.02,3.5],
    [12,24,0.96,5.8],[-24,16,0.94,0.3],
  ];
  const BUSH_SPOTS = [
    [-12,-28,1.1,0.4],[12,-28,1.12,2.8],[20,-10,1.1,1.9],[-18,-12,1.08,5.0],[8,-38,1.0,3.8],
  ];

  const treeModels = ["Tree_1_A","Tree_2_A","Tree_2_C","Tree_3_A","Tree_4_A"].filter(k => objLib[k]);
  const rockModels = ["Rock_1_J","Rock_1_K","Rock_3_A","Rock_3_C","Rock_3_E","Rock_3_G"].filter(k => objLib[k]);
  const bushModels = ["Bush_1_A","Bush_2_A"].filter(k => objLib[k]);

  const ghostGroup = new THREE.Group();
  ghostGroup.name = "existing_objects";

  function placeGhost(tmpl, x, z, s, r) {
    const m = tmpl.clone();
    m.scale.setScalar(s);
    m.position.set(x, 0, z);
    m.rotation.y = r;
    /* Make semi-transparent so they're clearly "reference" */
    m.traverse(c => { if (c.isMesh) { c.material = c.material.clone(); c.material.transparent = true; c.material.opacity = 0.4; c.material.depthWrite = false; } });
    ghostGroup.add(m);
  }

  if (treeModels.length) TREE_SPOTS.forEach(([x,z,s,r], i) => placeGhost(objLib[treeModels[i % treeModels.length]], x, z, s, r));
  if (rockModels.length) ROCK_SPOTS.forEach(([x,z,s,r], i) => placeGhost(objLib[rockModels[i % rockModels.length]], x, z, s, r));
  if (bushModels.length) BUSH_SPOTS.forEach(([x,z,s,r], i) => placeGhost(objLib[bushModels[i % bushModels.length]], x, z, s, r));

  scene.add(ghostGroup);
  console.log(`Showing ${TREE_SPOTS.length + ROCK_SPOTS.length + BUSH_SPOTS.length} existing game objects as ghosts`);
}

/* ═══════════════════════════════════════════
   Init
   ═══════════════════════════════════════════ */
buildPalette();
await loadAllModels();
await loadExistingGameObjects();
await loadExistingMap();
animate();
console.log("Map Editor ready — place objects on the map.");
</script>
</body>
</html>
